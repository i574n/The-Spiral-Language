nominal dict key value = mut {
    table : a u64 `(real_dict.bucket_type `key `value)
    total_size : u64
    limit : u64
    }

// Iterates over the dictionary and passes the value to on_succ if it finds a key match otherwise it calls on_fail.
// The callback arguments can be used to set, remove and add relevant value to the dictionary.
inl atKey forall key value ret. (x : dict key value) key cont : ret =
    open table
    open generic
    inl run funs (x : dictg _ key value) : ret = atKey funs x key cont
    real
    inl (dict x) = x
    typecase `(x.table) with
    | a u64 (caching_bucket _ _) => run `caching_bucket (caching_funs `key `value) (dictg `caching_bucket `key `value x)
    | a u64 (pure_bucket _ _) => run `pure_bucket (pure_funs `key `value) (dictg `pure_bucket `key `value x)

inl EmptyDef = {size = 7u64; limit = 3u64}
let empty' forall key value. {size limit} : dict key value = dict <| mut {
    table = real
        typecase `(real_dict.bucket_type `key `value) with ~bucket =>
        am.init `a `u64 `bucket size (fun _ =>
            open table
            typecase bucket with
            | caching_bucket _ _ => (caching_funs `key `value).bucket_empty()
            | pure_bucket _ _ => (pure_funs `key `value).bucket_empty()
            )
    total_size = 0
    limit = limit
    }

// Creates an empty dictionary with the table length for the given target capacity.
inl create total_size =
    let rec loop (x & {size limit}) =
        if total_size >= limit * size then loop {x with size#=generic.table_length_grow; limit#=(+) 2}
        else x
    empty' (loop EmptyDef)
    
// Creates an empty dictionary.
inl empty forall key value. : dict key value = empty' EmptyDef

// Indexes into the dictionary at the given key. Raises an exception if the key is not present.
let index x key =
    atKey x key {
        on_succ=fun value _ => value
        on_fail=fun _ => failwith "The key is not present in the dictionary."
        }

// Adds a key value pair to the dictionary. Raises an exception if the key already exists.
let add x key value = 
    atKey x key {
        on_succ=fun _ _ => failwith "The key already exists in the dictionary."
        on_fail=fun add => add value . value
        } |> ignore

// Sets a key value pair to the dictionary. Replaces the existing value if present.
let set x key value =
    atKey x key {
        on_succ=fun value {set} => set value . value
        on_fail=fun add => add value . value
        } |> ignore

// Tries finding a value of the specified key in the dictionary.
let tryFind x key =
    atKey x key {
        on_succ=fun value _ => Some: value
        on_fail=fun _ => None
        }

// Checks whether key the key is present in the dictionary.
let contains x key =
    atKey x key {
        on_succ=fun _ _ => true
        on_fail=fun _ => false
        }

// Tries removing a key from a dictionary. Returns boolean whether the operation succeeded.
let tryRemove x key =
    atKey x key {
        on_succ=fun value {remove} => remove() . true
        on_fail=fun _ => false
        }

// Tries removing a key from a dictionary. Throws an exception if the key is not present.
let remove x key = if tryRemove x key = false then failwith "The key is not present in the dictionary."

// If the key is not in the dictionary it executes the given function and adds its result to the dictionary. Otherwise it
// returns the already existing result.
inl memoize ~x f ~key = join
    atKey x key {
        on_succ=fun value _ => value
        on_fail=fun add => inl v = f key in add v . v
        }

// Threads over all the key/value pairs in the dictionary using the given state and the folding function.
inl fold forall key value s. (f : s -> key * value -> s) ~(s : s) ~(x : dict key value) : s = join real
    typecase `(x.table) with a u64 ~bucket => 
    am.fold `a `u64 `bucket `s (fun s x =>
        open table
        match x with
        | (caching_bucket x) => am.fold `ra `u64 `({key : key; value : value; hkey : u64}) `s (fun s {key value} => f s (key,value)) s x
        | (pure_bucket x) => am.fold `ra `u64 `({key : key; value : value}) `s (fun s {key value} => f s (key,value)) s x
        ) s x.table