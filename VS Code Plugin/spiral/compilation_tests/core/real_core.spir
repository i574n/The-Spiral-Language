// Raises a type error.
inl error_type x = !!!!ErrorType(x)
// Prints an expression at compile time.
inl print_static x = !!!!PrintStatic(x)
// Pushes the expression to runtime.
inl dyn x = !!!!Dyn(x)
// Indexes the layout type.
inl (~*) x = !!!!LayoutIndex(x)
// Indexes the layout type.
inl (~!) x = !!!!LayoutIndex(x)

// Unary negation.
inl (~-) x = !!!!Neg(x)
// Evaluates an expression and throws away the result.
inl ignore x = ()
// Returns an expression after evaluating it.
inl id x = x
// Throws away the second argument and returns the first.
inl const x _ = x
// Applies the unit to the function.
// (() -> a) -> a
inl unconst x = x()
// Creates an array with the given type and the size.
inl array_create forall typ. size = !!!!ArrayCreate(`typ,size)
// Returns the length of an array. Not applicable to Cuda arrays.
inl array_length ar = !!!!ArrayLength(ar)

// Binary addition.
inl (+) a b = !!!!Add(a,b)
// Binary subtraction.
inl (-) a b = !!!!Sub(a,b)
// Binary multiplication.
inl (*) a b = !!!!Mult(a,b)
// Binary power.
inl (**) a b = !!!!Pow(a,b)
// Binary division.
inl (/) a b = !!!!Div(a,b)
// Binary modulo.
inl (%) a b = !!!!Mod(a,b)

// Natural Logarithm.
inl log x = !!!!Log(x)
// Exponent.
inl exp x = !!!!Exp(x)
// Hyperbolic tangent. 
inl tanh x = !!!!Tanh(x)
// Square root.
inl sqrt x = !!!!Sqrt(x)

// 32/64-bit float infinity
inl inf forall t. = !!!!Infinity(`t)

// Applies the first argument to the second.
inl (|>) a b = b a
// Applies the second argument to the first.
inl (<|) a b = a b
// Applies the third argument to the first and then the result of that to the second.
inl (>>) a b x = b (a x)
// Applies the third argument to the second and then the result of that to the first.
inl (<<) a b x = a (b x)

// Binary less-than-or-equals.
inl (<=) a b = !!!!LTE(a,b)
// Binary less-than.
inl (<) a b = !!!!LT(a,b)
// Binary equals.
inl (=) a b = !!!!EQ(a,b)
// Binary unequals.
inl (<>) a b = !!!!NEQ(a,b)
// Binary greater-than.
inl (>) a b = !!!!GT(a,b)
// Binary greater-than-or-equals.
inl (>=) a b = !!!!GTE(a,b)

// Bitwise and.
inl (&&&) a b = !!!!BitwiseAnd(a,b)
// Bitwise or.
inl (|||) a b = !!!!BitwiseOr(a,b)
// Bitwise xor.
inl (^^^) a b = !!!!BitwiseXor(a,b)

// Shift left.
inl (<<<) a b = !!!!ShiftLeft(a,b)
// Shift right.
inl (>>>) a b = !!!!ShiftRight(a,b)

// Gets the first elements of a tuple.
inl fst (a,b) = a
// Gets the second element of a tuple.
inl snd (a,b) = b

// Unary negation.
inl not x = x = false
// Indexes into a string.
inl string_index x i = !!!!StringIndex(x,i)
// Slices a string between the two endpoints.
inl string_slice x (from:to:) = !!!!StringSlice(x,from,to)
// Returns the length of a string.
inl string_length x = !!!!StringLength(x)

// Returns boolean whether the expression is a literal.
inl lit_is x = !!!!LitIs(x)
// Returns boolean whether the expression is a primitive type.
inl prim_is x = !!!!PrimIs(x)
// Returns boolean whether the expression is a symbol.
inl symbol_is x = !!!!SymbolIs(x)
// Returns boolean whether the expression is a runtime variable.
inl var_is x = !!!!VarIs(x)
// Returns boolean whether the expression is an union.
inl union_is x = !!!!UnionIs(x)
// Returns boolean whether the expression is a heap allocated union.
inl heap_union_is x = !!!!HeapUnionIs(x)
// Returns boolean whether the expression is a layout type.
inl layout_is x = !!!!LayoutIs(x)
// Returns boolean whether the expression is a nominal type.
inl nominal_is x = !!!!NominalIs(x)
// Strips the nominal wrapper from the value.
inl nominal_strip x = !!!!NominalStrip(x)
// Returns boolean whether the type has the relevant prototype.
inl prototype_has forall t. prot = !!!!PrototypeHas(prot, `t)
// Returns boolean whether the float is a Nan.
inl nan_is x = !!!!NanIs(x)

// Raises an exception at runtime.
inl failwith forall typ. msg = !!!!FailWith(`typ,msg)
// Asserts an expression. If the conditional is a literal it raises a type error instead.
inl assert c msg = 
    inl raise = 
        if lit_is c && lit_is msg then error_type
        else failwith ()
    
    if c = false then raise msg
// Returns the maximum of the two expressions.
inl max a b = if a >= b then a else b
// Returns the minimum of the two expressions.
inl min a b = if a < b then a else b
// Returns the absolute value.
inl abs x = max x -x
// The template for lit_min and lit_max.
inl lit_comp op a b =
    if lit_is a && lit_is b then op a b
    elif lit_is a then a
    elif lit_is b then b
    else error_type "a or b needs to be a literal"

// Returns the compile time expressible maximum of the two expressions.
inl lit_max x = lit_comp max x
// Returns the compile time expressible minimum of the two expressions.
inl lit_min x = lit_comp min x

// Maps over a record.
inl record_map f a = !!!!RecordMap(f,a)
// Iterates over a record.
inl record_iter f a = !!!!RecordIter(f,a)
// Filters a record at compile time.
inl record_filter f a = !!!!RecordFilter(f,a)
// Folds over a record left to right.
inl record_foldl f s a = !!!!RecordFoldL(f,s,a)
// Folds over a record right to left.
inl record_foldr f a s = !!!!RecordFoldR(f,s,a)
// Returns the record length.
inl record_length m = !!!!RecordLength(m)

inl rec (=) a b =
    match a, b with
    | (a, a'), (b, b') => a = b && a' = b'
    | {} & a, {} & b => record_foldr (fun (state:next key:value:) res => res && match b with { $key=value'} => next (value = value')) a id true
    | (), () => true
    | a, b => 
        if symbol_is a then true
        elif layout_is a then *a = *b
        elif union_is a then
            inl body () = 
                if prototype_has `(`a) equable then equable `(`a) a b
                else !!!!Unbox2(a,b,(fun (_,a,b) => a = b),(fun () => false))
            if heap_union_is a && var_is a && var_is b then (join body()) : bool 
            else body()
        elif nominal_is a then
            if prototype_has `(`a) equable then equable `(`a) a b
            else nominal_strip a = nominal_strip b
        else !!!!EQ(a,b)

// Structural polymorphic equality for every type in the language (apart from functions.)
inl (=) a b = !!!!AssertTypeEq(a,b) . a = b

// Structural polymorphic inequality for every type in the language (apart from functions.)
inl (<>) a b = (a = b) <> true

// Returns the i32 tag of an union.
inl union_tag x = !!!!UnionTag(x)

// Structural polymorphic comparison for every type in the language (apart from functions.)
inl rec comp a b =
    match a, b with
    | (a, a'), (b, b') => 
        inl x = comp a b 
        if eq_is x then comp a' b' else x
    | {} & a, {} & b => 
        record_foldr (fun (state:next key:value:) res => 
            if eq_is res then match b with { $key=value'} => next (comp value value') else res
            ) a id EQ
    | (), () => EQ
    | a, b => 
        if symbol_is a then EQ
        elif layout_is a then comp *a *b
        elif union_is a then
            inl body () = 
                if prototype_has `(`a) comparable then comparable `(`a) a b
                else !!!!Unbox2(a,b,(fun (_,a,b) => comp a b),(fun () => comp (union_tag a) (union_tag b)))
            if heap_union_is a && var_is a && var_is b then (join body()) : order 
            else body()
        elif nominal_is a then
            if prototype_has `(`a) comparable then comparable `(`a) a b
            else comp (nominal_strip a) (nominal_strip b)
        else 
            if !!!!LT(a,b) then LT
            elif !!!!GT(a,b) then GT
            else EQ