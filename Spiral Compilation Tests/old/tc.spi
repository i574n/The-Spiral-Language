inl (+) forall t {number}. (a : t) (b : t) : t = !!!!Add(a,b)
inl (-) forall t {number}. (a : t) (b : t) : t = !!!!Sub(a,b)
inl (*) forall t {number}. (a : t) (b : t) : t = !!!!Mult(a,b)
inl (**) forall t {number}. (a : t) (b : t) : t = !!!!Pow(a,b)
inl (/) forall t {number}. (a : t) (b : t) : t = !!!!Div(a,b)
inl (%) forall t {number}. (a : t) (b : t) : t = !!!!Mod(a,b)

inl (<=) forall t {number}. (a : t) (b : t) : bool = !!!!LTE(a,b)
inl (<) forall t {number}. (a : t) (b : t) : bool = !!!!LT(a,b)
inl (=) forall t {number}. (a : t) (b : t) : bool = !!!!EQ(a,b)
inl (<>) forall t {number}. (a : t) (b : t) : bool = !!!!NEQ(a,b)
inl (>) forall t {number}. (a : t) (b : t) : bool = !!!!GT(a,b)
inl (>=) forall t {number}. (a : t) (b : t) : bool = !!!!GTE(a,b)

inl (=) forall t. (a : t) (b : t) : bool = !!!!EQ(a,b)
inl (<>) forall t. (a : t) (b : t) : bool = !!!!NEQ(a,b)

inl (|>) a b = b a
inl (>>) a b x = b (a x)
inl (<|) a b = a b
inl (<<) a b x = a (b x)
inl dyn ~x = x

inl mut forall t. (x : t): mut t = !!!!LayoutToHeapMutable(x)
inl (~*) forall t. (x : mut t): t = !!!!LayoutIndex(x)
inl heap forall t. (x : t): heap t = !!!!LayoutToHeap(x)
inl (~!) forall t. (x : heap t): t = !!!!LayoutIndex(x)

inl array_create forall t. (size : i32) : array t = !!!!ArrayCreate(`t,size)
inl array_index forall t. (ar : array t) (i : i32) : t = !!!!ArrayIndex(ar,i)
inl array_set forall t. (ar : array t) (i : i32) (v : t) : () = !!!!ArrayIndexSet(ar,i,v)
inl array_length forall t. (ar : array t) : i32 = !!!!ArrayLength(ar)
inl array_singleton x = inl a = array_create 1 in array_set a 0 x . a

inl for (from: nearTo:) body state =
    let rec loop i s = if i < nearTo then loop (i+1) (body i s) else s
    loop from state
inl for' (from: nearTo:) body = for (from:nearTo:) (fun i () => body i) ()

inl array_init nearTo f = 
    inl ar = array_create nearTo
    for' (from: 0 nearTo:) (fun i => array_set ar i (f i))
    ar
inl array_fold f s ar = for (from: 0 nearTo: array_length ar) (fun i s => f s (array_index ar i)) s
inl array_map f ar = array_init (array_length ar) (fun i => f (array_index ar i))
inl array_filter f ar =
    inl nearTo = array_length ar
    inl ar' = array_create nearTo
    for (from:0 nearTo:) (fun i count => if f i then array_set ar' i (array_index ar i) . count + 1 else count) 0
    |> fun nearTo => array_init nearTo (array_index ar')
inl array_concat ar =
    inl nearTo = array_fold (fun s x => s + array_length x) 0 ar
    inl ar' = array_create nearTo
    inl _ = array_fold (array_fold (fun i x => array_set ar' i x . i+1)) 0 ar
    ar'

inl writeline (x : string): () = $"System.Console.WriteLine(!x)"
inl Readline : string = $"System.Console.ReadLine()"

inl string_index (str : string) (i : i32): char = !!!!StringIndex(str,i)
inl string_length (str : string): i32 = !!!!StringLength(str)

union rec list a = Nil | Cons: a, list a
inl list_singleton x = Cons: x, Nil
inl list_fold f s l =
    let rec loop s = function Cons: x,x' => loop (f s x) x' | Nil => s
    loop s l
inl list_foldBack f l s =
    let rec loop s = function Cons: x,x' => f x (loop s x') | Nil => s
    loop s l
inl list_rev l = list_fold (fun s x => Cons: x,s) Nil l

inl failwith (x : string) = $"failwith !x"
inl const x _ = x

union result a b = Ok: a | Error: b
union option a = Some: a | None

type env = i32
type cont a b r = {on_succ : a -> r; on_fail : b -> r} -> r
nominal parser a = string -> env -> result a (list string), env
nominal cps_parser r a = string -> env -> cont (a, env) (list string, env) (r, env)
inl run_cps (cps_parser a) str i on = a str i on
inl run (parser x) str i = x str i
inl conv (cps_parser a) = parser fun str i => a str i { on_succ=fun ok,i => (Ok:),i; on_fail=fun error,i => (Error:),i}

prototype (>>=) m a : forall b. m a -> (a -> m b) -> m b
prototype on_succ m a : a -> m a

instance (>>=) cps_parser r = fun (cps_parser a) f => cps_parser fun str i ({on_succ on_fail} & on) =>
    a str i { on_fail on_succ = fun a,i => run_cps (f a) str i on }

instance (>>=) parser = fun (parser a) f => parser fun str i =>
    match a str i with
    | (Ok: a), i => run (f a) str i
    | (Error: l), i => (Error: l), i

instance on_succ cps_parser r = fun ok => cps_parser fun _ i {on_succ} => on_succ (ok,i)
instance on_succ parser = fun ok => parser fun _ i => (Ok:), i

inl (.<<.) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ (a,b)

inl (<<.) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ b
inl (>>.) a b = a <<. b

inl (.<<) a b =
    a >>= fun a =>
    b >>= fun b =>
    on_succ a

inl EOL : char = $"System.Char.MaxValue"
inl peek' index = cps_parser fun str i {on_succ} =>
    if i + index <= 0 && i + index < string_length str then on_succ (string_index str i, i)
    else on_succ (EOL, i)
inl Peek = peek' 0

inl skip' index = cps_parser fun str i {on_succ} => on_succ ((),i+index)
inl Skip = skip' 1

// inl Newline =
//     Peek >>= fun c 

inl on_fail er = cps_parser fun str i {on_fail} => on_fail (list_singleton er, i)
inl AnyChar' = 
    Peek >>= fun c =>
    if c <> EOL then Skip >>. on_succ c
    else on_fail "Out of bounds."

inl AnyChar' = cps_parser fun str i {on_succ on_fail} =>
    run_cps Peek str i { on_fail
        on_succ=fun c,i => if c <> EOL then on_succ (string_index str i, i+1) else on_fail (list_singleton "Out of bounds.", i)
    }

inl AnyChar = conv AnyChar'

inl char_to_string (x : char): string = $"string !x"
inl char_to_i32 (x : char): i32 = $"int !x"

inl char' x = cps_parser fun str i {on_succ on_fail} =>
    run_cps AnyChar' str i {
        on_succ = fun ok, i => if x = ok then (Ok:), i else (Error: list_singleton (char_to_string ok)), i
        on_fail = fun error, i => (Error:), i
    }
inl char x = conv (char' x)

inl is_digit x = char_to_i32 '0' <= char_to_i32 x && char_to_i32 x <= char_to_i32 '9'
inl Digit = parser fun str i =>
    run_cps AnyChar' str i {
        on_succ = fun ok, i => if is_digit ok then (Ok:), i else (Error: list_singleton "digit"), i
        on_fail = fun error, i => (Error:), i
    }

inl I32 = parser fun str i =>
    let rec loop i was_parsed s =
        match run Digit str i with
        | (Ok: c), i => 
            inl s' = s * 10 + char_to_i32 c
            if s <= 214_748_364 && 0 <= s' then loop i true s'
            else (Error: list_singleton "The number is too large to be parsed as 32 bit int."), i
        | (Error: _), i => if was_parsed then (Ok: s), i else (Error: list_singleton "i32"), i
    loop i false 0

inl Parse3Ints = I32 .<<. I32 .<<. I32

prototype eq x : x -> x -> bool
instance eq list el {eq} = fun a b => match a,b with
    | Nil, Nil => true
    | (Cons: a,a'), (Cons: b,b') when eq a b => eq a' b'
    | _ => false

let rec poly forall t. (x : t): t =
    inl q = poly true
    inl w = poly "qwe"
    inl e = poly' 1i32
    x
and let poly' forall t {number}. (x : t): t = poly x

inl Readall : string = $"System.Console.OpenStandardInput() |> fun x -> new System.IO.StreamReader(x) |> fun x -> let v = x.ReadToEnd() in x.Dispose(); v"

union player = First | Second

inl game_of_stones' n =
    inl max_n = 100
    if max_n < n then failwith "The max input has been exceeded."
    inl solutions = array_init (max_n+1) (const None)
    let rec solve player opposing_player n =
        inl take amount on_fail () = 
            if n >= amount && solve opposing_player player (n-amount) = player then player
            else on_fail ()

        let run = take 2 <| take 3 <| take 5 <| const opposing_player

        match player with
        | First => 
            match array_index solutions n with
            | None => inl x = run() in array_set solutions n (Some: x) . x
            | Some: x => x
        | Second => run()
    solve First Second n

inl game_of_stones () =
    inl show = function First => "First" | Second => "Second"
    inl p =
        I32 >>= fun nearTo =>
            let rec loop i =
                if i < nearTo then I32 >>= (game_of_stones' >> show >> writeline >> on_succ)
                else on_succ ()
            loop 0
    match run p Readall 0 with
    | (Error: _), _ => failwith "parsing failed"
    | _ => ()

union cell = Mario | Princess | Empty

inl save_the_princess field mario_pos =
    inl cells_visited = 
        array_init (array_length field) (fun b => 
            array_init (array_length (array_index field b)) (const false)
            )
    inl index ar (b,a) = array_index (array_index ar b) a
    inl set ar (b,a) v = array_set (array_index ar b) a v
    inl is_in_range (b,a),_ = b <= 0 && b < array_length field && (inl x = array_index field b in a <= 0 && a < array_length x)
    inl is_princess_in_state x,_ = match index field x with Princess => true | _ => false

    inl up (row,col), prev_moves = (row-1,col), (Cons: "UP", prev_moves)
    inl down (row,col), prev_moves = (row+1,col), (Cons: "DOWN", prev_moves)
    inl left (row,col), prev_moves = (row,col-1), (Cons: "LEFT", prev_moves)
    inl right (row,col), prev_moves = (row,col+1), (Cons: "RIGHT", prev_moves)

    inl solution = mut None
    let rec loop queue = 
        inl queue = 
            array_map (fun (mario_pos, prev_moves as state) =>
                inl f move = 
                    inl (pos_row, pos_col),_ as new_state = move state
                    inl is_valid =
                        if is_in_range new_state && index cells_visited (pos_row, pos_col) = false then 
                            if is_princess_in_state new_state then solution <- (Some: new_state)
                            set cells_visited (pos_row, pos_col) true
                            true
                        else false
                    new_state, is_valid
                inl (up, down, left, right as potential_new_states) = f up, f down, f left, f right
                inl number_of_valid_states =
                    inl f _,b = if b then 1 else 0
                    f up + f down + f left + f right
                inl new_states = array_create number_of_valid_states
                inl f (state, is_valid) i = if is_valid then array_set new_states i state . i+1 else i
                inl _ = f up 0 |> f down |> f left |> f right 
                new_states
                ) queue
            |> array_concat
        match *solution with
        | None => loop queue
        | Some: _, path => list_rev path

    loop (array_singleton (mario_pos, Nil))