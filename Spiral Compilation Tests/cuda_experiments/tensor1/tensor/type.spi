open corebase
open utils

nominal tensor_body dim el = {
    array : array el
    stride : dim
    offset : int
    }

nominal tensor dim el = {
    bodies : `(infer `(tensor_body dim) `el)
    dim : dim
    }

inl fromArray forall t. (x : array t) : tensor int t = tensor {dim = length x; bodies = real tensor_body `int `t {array = x; stride = 1; offset = 0}}

inl create forall dim el. (dim : dim) : tensor dim el = 
    inl stride, len = real calculate_stride_len dim
    inl create_body forall t. : tensor_body dim t = tensor_body {
        array = create len
        offset = 0
        stride 
        }
    tensor {dim bodies=real infer_templ `el create_body}

inl index forall dim el. (tensor {bodies dim} : tensor dim el) (i : dim) : el = real 
    assert_indices i dim
    map (fun (tensor_body {array stride offset}) =>
        typecase `array with
        | ~ar ~el => index `ar `el (calculate_offset stride i offset)
        ) bodies

inl set forall dim el. (tensor {bodies dim} : tensor dim el) (i : dim) (v : el) : () = real 
    assert_indices i dim
    iter2 (fun (tensor_body {array stride offset}) v =>
        typecase `array with
        | ~ar ~el => set `ar `el (calculate_offset stride i offset) v
        ) bodies v

inl length forall dim el. (tensor {dim} : tensor dim el) : int = real
    open real_core
    foldBack (*) dim 1

// Zips two tensors. Apart from dimension checking, all the work is done at compile time.
inl zip forall dim a b. (a : tensor dim a) (b : tensor dim b) : tensor dim (a * b) =
    assert (a.dim = b.dim) "The two tensors have to have the same dimensions for zipping to work."
    tensor {dim = a.dim; bodies = real a.bodies, b.bodies}

// Should only be used to rearrange internal fields. Is a compile time operation.
inl rezip forall dim a b. (f : a -> b) (a : tensor dim a) : tensor dim b =
    tensor {dim = a.dim; bodies=real open real_core in f a.bodies |> assert_term_vars_are_equal a.bodies}

// Should only be used to rearrange internal fields. Is a compile time operation.
inl reorder forall a b el. (f : a -> b) (a : tensor a el) : tensor b el = tensor {
    dim = f a.dim |> assert_term_vars_are_equal a.dim
    bodies = real
        map (fun (tensor_body r as x) =>
            typecase `x with
            | tensor_body a ~el => tensor_body `b `el {r with stride #= f}
            ) a.bodies
    }

inl apply_templ forall dim a b el. (fst : dim -> a) (snd : dim -> b) (tensor {bodies dim} : tensor dim el) (i : a) : tensor b el = real
    assert_indices i (fst dim)
    tensor `b `el {
        dim = snd dim
        bodies = 
            map (fun (tensor_body {array stride offset} as x) =>
                typecase `x with
                | tensor_body (a * b) ~el => tensor_body `b `el {
                    array
                    stride = snd stride
                    offset = calculate_offset (fst stride) i offset
                    }
                ) bodies
        }
inl apply_left forall a b el. : tensor (a * b) el -> a -> tensor b el = apply_templ fst snd
inl apply_right forall a b el. : tensor (a * b) el -> b -> tensor a el = apply_templ snd fst

inl view_templ forall dim dim' el. (f : dim -> dim') (g : dim -> dim' -> dim) (tensor {bodies dim} : tensor dim el) (i : {from : dim'; nearTo : dim'}) : tensor dim el = real
    assert_indices_view i.from i.nearTo (f dim)
    tensor `dim `el {
        dim = map2 (fun from nearTo => nearTo - from) i.from i.nearTo |> g dim
        bodies = 
            map (fun (tensor_body {array stride offset} as x) =>
                typecase `x with
                | tensor_body dim ~el => tensor_body `dim `el {
                    array stride offset = calculate_offset (f stride) i.from offset
                    }
                ) bodies
        }

inl view forall dim el. : tensor dim el -> {from : dim; nearTo : dim} -> tensor dim el = view_templ id (fun dim dim' => dim')
inl view_left forall a b el. : tensor (a * b) el -> {from : a; nearTo : a} -> tensor (a * b) el = view_templ fst (fun dim dim' => dim', snd dim)
inl view_right forall a b el. : tensor (a * b) el -> {from : b; nearTo : b} -> tensor (a * b) el = view_templ snd (fun dim dim' => fst dim, dim')

inl split_templ forall dim a b el. (f : dim -> a) view (t,i : tensor dim el * (a * b)) : tensor dim el * tensor dim el * b =
    inl assert_split (dim : a) : () = real
        open real_core
        inl prod i = foldBack (*) i 1
        inl len_dim = prod dim
        inl len_i = 
            inl rec f = function
                | a, b => prod a + f b
                | x => prod x
            f i
        assert (len_dim = len_i) "The size of tensor dimension being split must equal the sum of the arguments."
    assert_split (f t.dim)
    view t {from=real map (const 0) (fst i); nearTo=fst i}, view t {from=fst i; nearTo=f t.dim}, snd i

inl split forall dim dim' el. : tensor dim el * (dim * dim') -> tensor dim el * (tensor dim el * dim') = split_templ id view
inl split_left forall a b dim' el. : tensor (a * b) el * (a * dim') -> tensor (a * b) el * (tensor (a * b) el * dim') = split_templ fst view_left
inl split_right forall a b dim' el. : tensor (a * b) el * (b * dim') -> tensor (a * b) el * (tensor (a * b) el * dim') = split_templ snd view_right

inl flatten forall dim el. (tensor {dim bodies} : tensor dim el) : tensor int el = tensor {
    dim = real open real_core in foldBack (*) dim 1
    bodies = real
        map (fun (tensor_body r as x) =>
            typecase `x with
            | tensor_body dim ~el => tensor_body `int `el {r with stride #= assert_stride_contiguous dim }
            ) bodies
    }

inl reshape forall dim dim' el. (x : tensor dim el) (dim' : dim') : tensor dim' el = 
    inl stride, _ = real calculate_stride_len dim'
    inl (tensor {bodies dim}) = flatten x
    tensor {
        dim = dim'
        bodies = real
            map (fun (tensor_body r as x) =>
                typecase `x with
                | tensor_body dim ~el => tensor_body `dim' `el {r with stride }
                ) bodies
        }

// Overloads the ;[] array constructor.
inl array forall t. (x : array_base t) : tensor int t = 
    inl array = array x
    tensor {dim = corebase.length array; bodies=real tensor_body `int `t {array stride=1; offset=0} }

// Assert the array length. If they are the same, substitutes it with the given length in the resulting array.
// Useful when then given length is known at compile time and the array length is known at runtime.
// In that case, the resulting array will have the length given at compile time.
inl assert_len forall dim el. (dim : dim) (tensor {dim=dim' bodies} : tensor dim el) : tensor dim el =
    assert (dim = dim') "Expected the length of the array to be the specified amount."
    tensor {dim bodies}