open corebase
open real_core

inl infer_templ forall el. g =
    inl rec f forall el. =
        typecase el with
        | ~a * ~b => f `a, f `b
        | {} => record_type_map (fun k => f) `el
        | _ => g `el
    f `el

// Infers the folded out type of an inferse array. For example, it would map the type `array (a * b)` to `array a * array b`.
// Also supports the same for records.
inl infer forall ar el. = infer_templ `el (forall el. => ``(ar el))

inl iter index ar =
    inl rec f = function
        | a, b => f a, f b
        | {} as ar => record_map (fun {value} => f value) ar
        | ar => index ar
    f ar

inl iter2 set ar v =
    inl rec f = function
        | (a, b), (va,vb) => f (a, va) . f (b, vb)
        | ({} & ar, {} & v) => record_iter (fun {key value} => f (ar key, value)) v
        | ar,v => set ar v
    f (ar, v)

inl assert_index (i, s) = // This could be made concise, but I want the generated code to come out clean.
    if lit_is i && lit_is s then
        if not (0 <= i && i < s ) then
            error_type "Tensor index out of bounds (detected at compile-time.)"
    else
        backend_switch {
            python = fun () => $"assert 0 <= !i < !s, 'Tensor range check'" : ()
            cuda = fun () => $"assert(0 <= !i && !i < !s (* Tensor range check *))" : ()
        }

inl rec assert_indices = function
    | (s,s'),(i,i') => assert_index (i, s) . assert_indices (s', i')
    | s, i => assert_index (i, s)

inl rec calculate_offset = function
    | (s,s'),(i,i') => s * i + calculate_offset (s', i')
    | s, i => s * i
