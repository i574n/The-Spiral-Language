open real_core

type ptr = array u8
type size = u64
type tag = i32

inl calculate_offsets forall el. =
    inl sizeof forall t. = !!!!Conv(`size, !!!!SizeOf(`t))
    inl align forall el. s = modup s (sizeof `el)
    inl rec f forall el. =
        open struct
        infer_mapFold `el (forall el. s =>
            if singleton_type_is `el then (exists [el] s), s
            elif union_type_is `el then
                inl tag_offset, s = f `tag s
                inl union_fields, s =
                    union_to_record `el forall r. =>
                    record_type_fold (fun (m,max_offset) key => forall value. =>
                        inl value, new_offset = f `value s
                        {m with $key=value}, max max_offset new_offset
                        ) ({}, s) `r
                (exists [el] { tag_offset union_fields }), s
            elif prim_type_is `el then
                inl s = align `el s
                (exists [el] s), s + sizeof `el
            else
                print_static `el // TODO: Put in string interpolation into the language.
                error_type "Unsupported type encountered during serialization. Check out the Spiral terminal for more info."
            )
    f `el (conv `size 0)

inl ptr_at_offset (ptr : ptr) (exists t. offset) = 
    backend_switch {
        cuda = fun () => $"(`t *)(!ptr+!offset)" : array t
        python = fun () => typecase cupy_type t with ~ct => $"!ptr[!offset:].view(`ct)" : array t
    }

nominal offsets t = `(calculate_offsets `t)
inl serialize forall el. (offsets (offsets, _) : offsets el) (ptr : ptr) (v : el) : () = 
    inl rec f offsets =
        open struct
        iter2 (fun (exists el. offset) v =>
            if singleton_type_is `el then ()
            elif union_type_is `el then
                inl { tag_offset union_fields } = offset
                f tag_offset (union_tag v)
                !!!!Unbox(v,fun k,v => f (union_fields k) v)
            elif prim_type_is `el then
                set `array `el (ptr_at_offset ptr (exists [el] offset)) 0 v // We need to use `ptr_at_offset` instead of setting the array directly in order to cast it to the correct type.
            else
                print_static `el // TODO: Put in string interpolation into the language.
                error_type "Unsupported type encountered during serialization. Check out the Spiral terminal for more info."
            ) offsets
    f offsets v

inl deserialize forall el. (offsets (offsets, _) : offsets el) (ptr : ptr) : el = 
    inl rec f offsets =
        open struct
        map (fun (exists el. offset) =>
            if singleton_type_is `el then
                typecase el with
                | () => ()
                | _ => type_lit_to_lit `el
            elif union_type_is `el then
                inl { tag_offset union_fields } = offset
                inl tag = f tag_offset
                union_untag `el tag
                    (fun k => forall v. => nominal_create `el (k, f (union_fields k))) 
                    (fun _ => failwith `el "Invalid tag.")
            elif prim_type_is `el then
                index `array `el (ptr_at_offset ptr (exists [el] offset)) 0
            else
                print_static `el // TODO: Put in string interpolation into the language.
                error_type "Unsupported type encountered during serialization. Check out the Spiral terminal for more info."
            ) offsets
    f offsets

