// The array template module. Generic functions for array like structures.
open corebase
open loop

// Statically sized array with a type literal for a dimension.
nominal sa dim el = $"array<`el,@dim>"

// Creates an empty array.
inl create' forall dim el. : sa dim el = $"array<`el,@dim> v$"
    
instance create sa dim = fun dim =>
    assert ((real real_core.type_lit_to_lit `dim) = dim) "The type level dimension has to equal the value passed at runtime into create."
    create'

// Indexes into an array.
instance index sa dim = fun ar i => $"!ar.v[!i]"
// Sets the value of an array at the specified index.
instance set sa dim = fun ar i v => $"!ar.v[!i] = !v"
// Returns the length of an array.
instance length sa dim = fun ar => real real_core.type_lit_to_lit `dim : int

open arraym

instance equable sa dim el = generic_equable
instance comparable sa dim el = generic_comparable

// Initializes array using the given function.
inl init forall dim el. f : sa dim el = init (real real_core.type_lit_to_lit `dim) f

// The inclusive Hillis & Steele scan.
inl scan_inclusive forall dim el. (f : el -> el -> el) (ar : sa dim el) =
    inl ar = map id ar
    while (fun by => by < length ar) (fun by =>
        forDown' {nearFrom=length ar; to=by} (fun i =>
            set ar i (f (index ar (i-by)) (index ar i))
            )
        by * 2
        ) 1 |> ignore
    ar
    
// Reduces the array in a tree like fashion using the provided function.
inl reduce forall dim_outer el. (f : el -> el -> el) (ar : sa dim_outer el) =
    open type_arith

    inl rec loop forall dim. (inp : sa dim el) : el =
        if 1 < length inp then
            inl out : sa (divup dim 2) el = create'
            for' {from=0; nearTo=length out} (fun i =>
                inl v =
                    inl i = i*2
                    if i+1 < length inp then f (index inp i) (index inp (i+1))
                    else index inp i
                set out i v
                )
            loop out
        else index inp 0

    loop ar

// The exclusive Bleloch scan
inl scan_exclusive forall dim_outer el. (f : el -> el -> el) s (ar : sa dim_outer el) =
    open type_arith

    inl rec loop forall dim. (inp : sa dim el) : sa dim el =
        if 1 < length inp then
            inl out : sa (divup dim 2) el = create'
            for' {from=0; nearTo=length out} (fun i =>
                inl v =
                    inl i = i*2
                    if i+1 < length inp then f (index inp i) (index inp (i+1))
                    else index inp i
                set out i v
                )
            inl out = loop out
            for' {from=0; nearTo=length out} (fun i =>
                inl s = index out i
                inl i = i*2
                if i+1 < length inp then
                    set inp (i+1) (f (index inp i) s)
                set inp i s
                )
            inp
        else
            set inp 0 s
            inp

    loop (map id ar)

open console
inl sa_print forall dim el. array_limit (x : sa dim el) : () =
    write "["
    loop.for' {from=0; nearTo=min array_limit (length x)} (fun i =>
        write (index x i)
        if i + 1 < length x then write "; "
        )
    if length x > array_limit then write "; ..."
    write "]"

instance printable sa dim el = sa_print 100