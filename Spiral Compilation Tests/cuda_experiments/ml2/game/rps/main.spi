open corebase
open corecuda

union action = Rock | Paper | Scissors
union player = Computer | Human
union event = 
    | StartGame
    | PlayerChanged : player * player
    | ActionSelected : action
union game_state =
    | GameNotStarted
    | WaitingForActionFromPlayerId : int
    | GameOver : action * action
union message =
    | ShowdownResult : action * action 
    | WaitingToStart
    | GameStarted

type ui_state = {
    pl_type : player * player
    game_state : game_state
    messages : message
    }

type game_state = {
    past_actions : sa_listm.sa_list 2 action
    // rng : ptr random.philox_state
    }

type state = {
    ui_state : ui_state
    game_state : game_state
    }

let rec game_step (action : option action) (state : state) : state =
    inl {ui_state game_state} = state
    // inl random_action() : action =
    //     inl actions : sam.sa 3 _ = arraym.fromList [Rock, 1; Paper, 1; Scissors, 1]
    //     random.sample_discrete actions game_state.rng
    inl random_action() : action = 
        global "import random"
        $'random.choice([!Rock, !Paper, !Scissors])'
    inl push_action x (ar : sa_listm.sa_list _ action) = sa_listm.push ar x . ar
    inl clear_actions (ar : sa_listm.sa_list _ action) = sa_listm.clear ar . ar
    match state.ui_state.game_state with
    | GameNotStarted | GameOver => state
    | WaitingForActionFromPlayerId id when id < 2 =>
        assert (length state.game_state.past_actions = id) "The number of past actions must equal the player id."
        inl pl_type = if id = 0 then fst ui_state.pl_type else snd ui_state.pl_type
        match pl_type with
        | Computer =>
            assert (action = None) "The computer player should never be receiving an action."
            inl action = random_action()
            {state with
                ui_state #= fun ui_state => {ui_state with game_state = WaitingForActionFromPlayerId(id+1)}
                game_state #= fun game_state => {game_state with past_actions #= push_action action}
            } |> game_step None
        | Human =>
            match action with
            | None => state
            | Some action =>
                {state with
                    ui_state #= fun ui_state => {ui_state with game_state = WaitingForActionFromPlayerId(id+1)}
                    game_state #= fun game_state => {game_state with past_actions #= push_action action}
                } |> game_step None
    | WaitingForActionFromPlayerId id => // showdown
        inl a0,a1 = open sa_listm in index game_state.past_actions 0, index game_state.past_actions 1
        {state with
            ui_state #= fun ui_state => {ui_state with 
                game_state = GameOver(a0,a1)
                messages = ShowdownResult(a0,a1)
                }
            game_state #= fun game_state => {game_state with past_actions #= clear_actions}
            }

let event_loop (msg : event) (state : state) : state =
    match msg with
    | StartGame => 
        {state with
            game_state #= fun game_state => {game_state with
                past_actions = sa_listm.create'
            }
            ui_state #= fun ui_state => {ui_state with
                game_state = WaitingForActionFromPlayerId 0
                messages = GameStarted
            }
        } |> game_step None
    | PlayerChanged pl_type =>
        {state.ui_state with pl_type}
        |> game_step None
    | ActionSelected action =>
        game_step (Some action) state

inl random_action() : string = 
    open serializer
    inl offsets = calculate_offsets
    inl ptr = create conv(offsets_size offsets)

    run fun () =>
        open random
        globals()
        inl from = rangem.threads_in_grid().from
        inl rng : _ philox_state = 
            init {seed = $"clock64()"; subsequence=conv from; offset=0}
        if from = 0 then
            open sam
            inl actions : sa 3 _ = arraym.fromList [Rock, 1; Paper, 1; Scissors, 1]
            inl action = sample_discrete actions rng
            serialize offsets ptr action

    match deserialize offsets ptr with
    | Rock => "Rock"
    | Paper => "Paper"
    | Scissors => "Scissors"

inl main() =
    inl s : state = {
        ui_state = {
            pl_type = Human, Computer
            game_state = GameNotStarted
            messages = WaitingToStart
        }
        game_state = {
            past_actions = sa_listm.create'
        }
    }
    event_loop StartGame s
    |> console.write_ln
