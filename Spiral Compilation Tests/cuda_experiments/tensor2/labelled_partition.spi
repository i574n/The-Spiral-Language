open corebase
open corecuda
open tensorm

inl labeled_partition_test (a : tensor (int * int) float) (b : tensor (int * int) float) =
    inl threads_per_block = 64
    inl blocks_per_grid = 1
    run blocks_per_grid threads_per_block (fun () =>
        global "#include <cooperative_groups.h>"
        global "#include <cooperative_groups/reduce.h>"
        global "using namespace cooperative_groups;"

        open cooperative_groups
        open tensorm.cuda

        inl block = create_block()
        inl tile : _ (_ 64 _) = create_thread_block_tile block

        loop_warps_in_grid' (2, 32) fun i =>
            inl x = tensor_index i a

            inl l = create_labeled_partition tile (snd i)
            inl x = $"reduce(!l, !x, plus<`float>())"

            if fst i = 0 then
                tensor_set (0, snd i) x b
        )


inl main() =
    inl random_normal dim =
        inl len : int = real tensorm.utils.prod dim
        inl t : array f32 = $"cp.random.normal(0,1,!len,cp.float32)" 
        fromArray t |> reshape (const dim)

    inl [a; b] = listm.map random_normal ([2, 32; 1, 32])
    labeled_partition_test a b
    console.write_ln (zip (apply 0 a) (apply 1 a))
    console.write_ln b
    global "from max_blocks_per_sm import max_blocks_per_sm"
    $"max_blocks_per_sm(cp.cuda.Device(),raw_module.get_function('entry0'),128,is_print=True)" : ()