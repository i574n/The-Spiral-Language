open nodes
open leduc

let process (l : list (observation card action)) =
    let rec action (c,l) = function
        | Cons: (Observation: x), x' => (c,listm.rev l |> listm.toArray) :: action (x,Nil) x'
        | Cons: (Action: x), x' => action (c,x :: l) x'
        | Nil => (c,listm.rev l |> listm.toArray) :: Nil
    match listm.rev l with
    | Cons: (Observation: x), x' => action (x,Nil) x' |> listm.toArray
    | _ => failwith "Expected a card."

inl create_net () =
    open torch
    !!!!Import("nets")

    inl input =
        open serialization.dense.array
        inl card = alt {king=Unit; queen=Unit; jack=Unit} : pu card
        inl action = alt {fold=Unit; call=Unit; raise=Unit} : pu action
        array 2 (card ** array 4 action)
    inl output =
        open serialization.sparse.int
        alt {fold=Unit; call=Unit; raise=Unit} : pu action

    inl c,b,a = denseSize input, 64u64, sparseSize output
    process >> runMasked {input output net = $"nets.small(!c,!b,!a)"}

inl funs update_state =
    inl net = create_net()
    player_funs {
        action = fun game_state p opp_prob dist next => 
            inl action = net (observations p) dist
            inl state = update_state game_state p opp_prob dist action
            next (action,state)
        terminal = fun s p r => ()
        } 

inl Init = uniform.init()
inl create update_state = {funs=funs update_state; init=Init}