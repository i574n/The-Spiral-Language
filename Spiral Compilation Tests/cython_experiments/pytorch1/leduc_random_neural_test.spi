open leduc

union observation = Action: action | Card: card
type dense_history = array (card * array action)

nominal game_interface o s a r = {
    state : s
    reward : {(+) : r -> r -> r; (*) : r -> r -> r; index : r -> u8 -> f64}
    player : {
        action : s -> u8 -> array a -> (a * s -> r) -> r
        observation_add : s -> u8 -> o -> s
        path_mult : s -> u8 -> f64 -> s
        }
    }

inl sample_all dist next {observations=o1,o2 players} =
    ()

let process (l : list observation) =
    let rec action (c,l) = function
        | Cons: (Card: x), x' => (c,listm.rev l |> listm.toArray) :: action (x,Nil) x'
        | Cons: (Action: x), x' => action (c,x :: l) x'
        | Nil => (c,listm.rev l |> listm.toArray) :: Nil
    match l with
    | Cons: (Card: x), x' => action (x,Nil) x' |> listm.toArray
    | _ => failwith "Expected a card."

open utils.torch

type leduc_net = serialized_net (array (card * array action)) action
inl Net : leduc_net =
    PyTorchImports
    !!!!Import("nets")

    inl input =
        open serialization.dense.array
        inl card = alt {king=Unit; queen=Unit; jack=Unit} : pu card
        inl action = alt {fold=Unit; call=Unit; raise=Unit} : pu action
        array 2 (card ** array 4 action)
    inl output =
        open serialization.sparse.int
        alt {fold=Unit; call=Unit; raise=Unit} : pu action

    inl c,b,a = denseSize input, 64u64, sparseSize output
    inl net = $"nets.leduc(!c,!b,!a)"
    serialized_net { net input output }

inl main() = ()