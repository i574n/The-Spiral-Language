open leduc

union observation = Action: action | Card: card
type dense_history = array (card * array action)

nominal framework o s a r = {
    reward : {(+) : r -> r -> r; (*) : r -> f64 -> r; index : r -> u8 -> f64}
    player : {
        action : s -> u8 -> array a -> (a * s -> r) -> r
        observation_add : s -> u8 -> o -> s
        observation_add_all : s -> o -> s
        path_mult : s -> u8 -> f64 -> s
        }
    }

inl terminal (pid,reward) _ : f64 = if pid = 0 then reward else -reward
inl f64 forall t {number}. (x : t) = $"<`f64>!x" : f64

inl sample_all_many' to_obs dist next (state, fr & framework {reward={(+) (*)} player={observation_add_all}}) =
    inl run i = inl x = a64.index dist i in next x (observation_add_all state (to_obs x), fr)
    inl nearTo = a64.length dist
    loop.for (from: 1 nearTo:) (fun i s => s + run i) (run 0) * (1 / f64 nearTo)
inl sample_all_many x = sample_all_many' card_ x

inl sample_all_one' to_obs dist next (state, fr & framework {reward={(+) (*)} player={observation_add_all}}) =
    inl run x = next x (observation_add_all state (to_obs x), fr)
    run (sampling.sample dist)
inl sample_all_one x = sample_all_one' card_ x

let process (l : list observation) =
    let rec action (c,l) = function
        | Cons: (Card: x), x' => (c,listm.rev l |> listm.toArray) :: action (x,Nil) x'
        | Cons: (Action: x), x' => action (c,x :: l) x'
        | Nil => (c,listm.rev l |> listm.toArray) :: Nil
    match l with
    | Cons: (Card: x), x' => action (x,Nil) x' |> listm.toArray
    | _ => failwith "Expected a card."

open utils.torch

type leduc_net = serialized_net (array (card * array action)) action
inl Net : leduc_net =
    PyTorchImports
    !!!!Import("nets")

    inl input =
        open serialization.dense.array
        inl card = alt {king=Unit; queen=Unit; jack=Unit} : pu card
        inl action = alt {fold=Unit; call=Unit; raise=Unit} : pu action
        array 2 (card ** array 4 action)
    inl output =
        open serialization.sparse.int
        alt {fold=Unit; call=Unit; raise=Unit} : pu action

    inl c,b,a = denseSize input, 64u64, sparseSize output
    inl net = $"nets.leduc(!c,!b,!a)"
    serialized_net { net input output }

inl main() = ()