open leduc

union history = Action: action | Card: card
type dense_history = array (card * array action)

let process (l : list history) =
    let rec action (c,l) = function
        | Cons: (Card: x), x' => (c,listm.rev l |> listm.toArray) :: action (x,Nil) x'
        | Cons: (Action: x), x' => action (c,x :: l) x'
        | Nil => (c,listm.rev l |> listm.toArray) :: Nil
    match l with
    | Cons: (Card: x), x' => action (x,Nil) x' |> listm.toArray
    | _ => failwith "Expected a card."

inl denseSize x = serialization.dense.array.size x
inl sparseSize x = serialization.sparse.int.size x

inl Net =
    !!!!Import("torch")
    !!!!Import("torch.nn")
    !!!!Import("torch.distributions")
    !!!!Import("nets")

    inl schemaIn =
        open serialization.dense.array
        inl card = alt {king=Unit; queen=Unit; jack=Unit} : pu card
        inl action = alt {fold=Unit; call=Unit; raise=Unit} : pu action
        array 2 (card ** array 4 action)
    inl schemaOut =
        open serialization.sparse.int
        alt {fold=Unit; call=Unit; raise=Unit} : pu action

    inl c = denseSize schemaIn
    inl b = 64u64
    inl a = sparseSize schemaOut

    open bindings.torch
    {
    net = $"nets.leduc(!c,!b,!a)" : net
    serialize = process >> serialize schemaIn
    deserialize = deserialize schemaOut
    }

inl main() = ()