nominal framework (s : * -> *) o a r = {
    reward : {(+) : r -> r -> r; (*) : r -> f64 -> r; index : r -> u8 -> f64}
    player : {
        action : s o -> u8 -> array a -> (a * s o -> r) -> r
        observation_add : s o -> option u8 -> o -> s o
        path_mult : s o -> u8 -> f64 -> s o
        }
    }

inl reward_2p_index reward pid = if pid = 0u8 then reward else -reward : f64
inl terminal (pid,reward) _ = reward_2p_index reward pid

type player observation = {path_prob : f64; observations : list observation}
nominal player_2p_state observation = player observation * player observation

inl player_2p_modify_state update (player_2p_state (a,b)) pid =
    match pid with
    | Some: pid => 
        inl update (i : u8) a = if pid = i then update a else a
        update 0 a, update 1 b
    | None => update a, update b
inl player_2p_observation_add state pid o = player_2p_modify_state (fun a => {a with observations#=((::) o)}) state pid
inl player_2p_path_mult state pid o = player_2p_modify_state (fun a => {a with path_prob#=((*) o)}) state pid
inl player_2p_action to_obs (a1,a2) (state & player_2p_state (x1,x2)) pid dist next =
    inl next a = inl state = player_2p_observation_add state (Some: pid) (to_obs a) in next (a, state)
    if pid = 0 then a1 x1 x2.path_prob dist next else a2 x2 x1.path_prob dist next

inl f64 forall t {number}. (x : t) = $"<`f64>!x" : f64
inl sample_many' to_obs pid dist next (state, fr & framework {reward={(+) (*)} player={observation_add}}) =
    inl run i = inl x = a64.index dist i in next x (observation_add state pid (to_obs x), fr)
    inl nearTo = a64.length dist
    loop.for (from: 1 nearTo:) (fun i s => s + run i) (run 0) * (1 / f64 nearTo)
inl draw_many' to_obs pid dist next (state, fr & framework {reward={(+) (*)} player={observation_add}}) =
    inl run i = inl x = a64.index dist i in next (x,a64.removeAtIndex i dist) (observation_add state pid (to_obs x), fr)
    inl nearTo = a64.length dist
    loop.for (from: 1 nearTo:) (fun i s => s + run i) (run 0) * (1 / f64 nearTo)
inl sample_one' to_obs pid dist next (state, fr & framework {player={observation_add}}) = 
    inl x = sampling.sample dist
    next x (observation_add state pid (to_obs x), fr)
inl draw_one' to_obs pid dist next (state, fr & framework {player={observation_add}}) = 
    inl (x,dist) = sampling.draw dist
    next (x,dist) (observation_add state pid (to_obs x), fr)

// Random player

open leduc

union observation = Action: action | Card: card

inl sample_many x = sample_many' card_ x
inl draw_many x = draw_many' card_ x
inl sample_one x = sample_one' card_ x
inl draw_one x = draw_one' card_ x

inl main () =
    inl fr = framework {
        reward={(+) (*) index=reward_2p_index}
        player={
            action=fun (player_2p_state state) pid (dist : array action) next =>
                failwith "TODO"
            observation_add=fun state pid (o : observation) =>
                failwith "TODO"
            path_mult=fun state pid r =>
                failwith "TODO"
            }
        }
    game {
        sample = fun pid dist next =>
            failwith ""
        draw = failwith "TODO"
        action = failwith "TODO"
        terminal = failwith "TODO"
        }
