prototype radd r : r -> r -> r
prototype rmult r : r -> f64 -> r
prototype rindex r : r -> u8 -> f64

nominal reward_2p = f64
instance radd reward_2p = fun (reward_2p a) (reward_2p b) => reward_2p (a+b)
instance rmult reward_2p = fun (reward_2p a) b => reward_2p (a+b)
instance rindex reward_2p = fun (reward_2p reward) pid => if pid = 0u8 then reward else -reward

prototype prob p : p -> f64
prototype prob_mult p : p -> f64 -> p
prototype observation_add p o a : p o a -> o -> p o a
prototype run p a : forall r. p a -> f64 -> array a -> (a * p a -> r) -> r

prototype prob_mult' p : p -> u8 -> f64 -> p
prototype observation_add' p o a : p o a -> u8 -> o -> p o a
prototype run' p a : forall r. p a -> u8 -> array a -> (a * p a -> r) -> r

nominal player_random o a = {path_prob : f64; observations : list o}
instance prob player_random o a = fun (player_random {path_prob}) => path_prob
instance prob_mult player_random o a = fun (player_random {path_prob} & p) x => player_random {p with path_prob#=((*) x)}
instance observation_add player_random = fun (player_random {path_prob} & p) x => player_random {p with observations#=((::) x)}
// instance run player_random = fun 

nominal players2 (p1 : * -> * -> *) (p2 : * -> * -> *) o a = p1 o a * p2 o a
instance prob_mult' players2 p1 {prob_mult} p2 {prob_mult} o a = fun (players2 (a,b)) pid prob =>
    inl update (i : u8) a = if pid = i then prob_mult a prob else a
    players2 (update 0 a, update 1 b)
instance observation_add' players2 p1 {observation_add} p2 {observation_add} = fun (players2 (a,b)) pid o =>
    inl update (i : u8) a = if pid = i then observation_add a o else a
    players2 (update 0 a, update 1 b)

type player observation = {path_prob : f64; observations : list observation}
nominal player_2p_state observation = player observation * player observation

inl player_2p_modify_state update (player_2p_state (a,b)) pid =
    match pid with
    | Some: pid => 
        inl update (i : u8) a = if pid = i then update a else a
        update 0 a, update 1 b
    | None => update a, update b
inl player_2p_observation_add state pid o = player_2p_modify_state (fun a => {a with observations#=((::) o)}) state pid
inl player_2p_path_mult state pid o = player_2p_modify_state (fun a => {a with path_prob#=((*) o)}) state pid
inl player_2p_action to_obs (a1,a2) (state & player_2p_state (x1,x2)) pid dist next =
    inl next a = inl state = player_2p_observation_add state (Some: pid) (to_obs a) in next (a, state)
    if pid = 0 then a1 x1 x2.path_prob dist next else a2 x2 x1.path_prob dist next

inl f64 forall t {number}. (x : t) = $"<`f64>!x" : f64
inl sample_many' to_obs pid dist next (state, fr & framework {reward={(+) (*)} player={observation_add}}) =
    inl run i = inl x = a64.index dist i in next x (observation_add state pid (to_obs x), fr)
    inl nearTo = a64.length dist
    loop.for (from: 1 nearTo:) (fun i s => s + run i) (run 0) * (1 / f64 nearTo)
inl draw_many' to_obs pid dist next (state, fr & framework {reward={(+) (*)} player={observation_add}}) =
    inl run i = inl x = a64.index dist i in next (x,a64.removeAtIndex i dist) (observation_add state pid (to_obs x), fr)
    inl nearTo = a64.length dist
    loop.for (from: 1 nearTo:) (fun i s => s + run i) (run 0) * (1 / f64 nearTo)
inl sample_one' to_obs pid dist next (state, fr & framework {player={observation_add}}) = 
    inl x = sampling.sample dist
    next x (observation_add state pid (to_obs x), fr)
inl draw_one' to_obs pid dist next (state, fr & framework {player={observation_add}}) = 
    inl (x,dist) = sampling.draw dist
    next (x,dist) (observation_add state pid (to_obs x), fr)

// Random player

open leduc

union observation = Action: action | Card: card

inl sample_many x = sample_many' card_ x
inl draw_many x = draw_many' card_ x
inl sample_one x = sample_one' card_ x
inl draw_one x = draw_one' card_ x

inl main () =
    inl fr = framework {
        reward={(+) (*) index=reward_2p_index}
        player={
            action=fun (player_2p_state state) pid (dist : array action) next =>
                failwith "TODO"
            observation_add=fun state pid (o : observation) =>
                failwith "TODO"
            path_mult=fun state pid r =>
                failwith "TODO"
            }
        }
    game {
        sample = fun pid dist next =>
            failwith ""
        draw = failwith "TODO"
        action = failwith "TODO"
        terminal = failwith "TODO"
        }
