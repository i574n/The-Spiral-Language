nominal dict key value = mut {
    table : a u64 (ra u64 {key : key; value : value; hkey : u64})
    total_size : u64
    limit : u64
    }

inl EmptyDef = {size = 7; limit = 3}
inl empty' {size limit} = dict <| mut {
    table = am.init size (fun _ => am.empty)
    total_size = 0
    limit = limit
    }

inl Empty = empty' EmptyDef

// Internal. Increases the dictionary capacity.
let resize (dict x) =
    inl table = x.table
    inl table_length' = length table * 3 / 2 + 3
    if table_length' <= length table then failwith "The table cannot be grown anymore."
    inl table' = am.init table_length' (fun i => am.empty)
    loop.for' (from: 0 nearTo: length table) (fun i =>
        inl bucket = index table i
        loop.for' (from: 0 nearTo: length table) (fun i =>
            inl a = index bucket i
            inl bucket' = index table' ((a.hkey &&& limit_max.u64()) % table_length')
            rm.add bucket' a
            )
        )
    x.table <- table'
    x.limit <- x.limit+2

// Internal. Iterates over the dictionary and passes the value to on_succ if it finds a key match otherwise it calls on_fail.
// The callback arguments can be used to set, remove and add relevant value to the dictionary.
inl atKey (dict x) key {on_succ on_fail} = 
    inl hkey = hash_cython key
    inl table = x.table
    inl bucket = index table ((hkey &&& limit_max.u64()) % length table)
    let rec loop i =
        if i < length bucket then 
            inl x = index bucket i
            if hkey = x.hkey && key = x.key then 
                on_succ x.value {
                    set = fun value => set bucket i {x with value}
                    remove = fun () => rm.pop bucket i |> ignore
                    }
            else loop (i+1)
        else
            on_fail (fun value => 
                rm.add bucket {key value hkey}
                x.total_size <- x.total_size+1
                if x.total_size >= x.limit * length x.table then resize (dict x)
                )
    loop 0

// Indexes into the dictionary at the given key. Raises an exception if the key is not present.
let index x key =
    atKey x key {
        on_succ=fun value _ => value
        on_fail=fun _ => failwith "The key is not present in the dictionary."
        }

// Adds a key value pair to the dictionary. Raises an exception if the key already exists.
let add x key value = 
    atKey x key {
        on_succ=fun _ _ => failwith "The key already exists in the dictionary."
        on_fail=fun add => add value . value
        } |> ignore

// Sets a key value pair to the dictionary. Replaces the existing value if present.
let set x key value =
    atKey x key {
        on_succ=fun value {set} => set value . value
        on_fail=fun add => add value . value
        } |> ignore

// Tries finding a value of the specified key in the dictionary.
let tryFind x key =
    atKey x key {
        on_succ=fun value _ => Some: value
        on_fail=fun _ => None
        }

// Checks whether key the key is present in the dictionary.
let contains x key =
    atKey x key {
        on_succ=fun _ _ => true
        on_fail=fun _ => false
        }

// Tries removing a key from a dictionary. Returns boolean whether the operation succeeded.
let tryRemove x key =
    atKey x key {
        on_succ=fun value {remove} => remove() . true
        on_fail=fun _ => false
        }

// Tries removing a key from a dictionary. Throws an exception if the key is not present.
let remove x key = if tryRemove x key = false then failwith "The key is not present in the dictionary."

// If the key is not in the dictionary it executes the given function and adds its result to the dictionary. Otherwise it
// returns the already existing result.
let memoize x f key =
    atKey x key {
        on_succ=fun value _ => value
        on_fail=fun add => inl v = f key in add v . v
        }