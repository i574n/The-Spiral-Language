union observation o a = Observation: o | Action: a
type pl (p : * -> * -> *) o a = { path_prob : f64; observations : list (observation o a); state : p o a }
inl prob ({path_prob} : pl _ _ _) = path_prob
inl prob_mult (x : pl _ _ _) prob = {x with path_prob#=(*) prob}
inl observation_add (x : pl _ _ _) o = {x with observations#=(::) (Observation: o)}
inl action_add (x : pl _ _ _) a = {x with observations#=(::) (Action: a)}

type pl2 (p1 : * -> * -> *) (p2 : * -> * -> *) o a = pl p1 o a * pl p2 o a

open leduc
inl nodes forall (p1 : * -> * -> *) (p2 : * -> * -> *) ret. dispatch : leduc_funs (pl2 p1 p2 _ _ * (f64 -> ret) -> ret) =
    {
    terminal = fun (pid,reward) (_,ret) => inl r = $"!reward" in ret (if pid = 0 then r else -r)
    action = fun pid ar f ((p1,p2),ret) =>
        inl next (prob,a) =
            let add pid' p = if pid = pid' then prob_mult (action_add p a) prob else p
            f a ((add 0 p1,add 1 p2),ret)
        dispatch ((pid,if pid = 0 then p1.observations else p2.observations),ar,next)
    draw = fun pid ar f => failwith ""
    sample = fun pid ar f => failwith ""
    }