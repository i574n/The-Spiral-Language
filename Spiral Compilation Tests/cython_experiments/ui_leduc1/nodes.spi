union observation o a = Observation: o | Action: a
type pl (p : * -> * -> *) o a = { path_prob : f64; observations : list (observation o a); state : p o a }
inl prob ({path_prob} : pl _ _ _) = path_prob
inl prob_mult (x : pl _ _ _) prob = {x with path_prob#=(*) prob}
inl observation_add (x : pl _ _ _) o = {x with observations#=(::) (Observation: o)}
inl action_add (x : pl _ _ _) a = {x with observations#=(::) (Action: a)}

type pl2 (p1 : * -> * -> *) (p2 : * -> * -> *) o a = pl p1 o a * pl p2 o a

open leduc
inl nodes forall (p1 : * -> * -> *) (p2 : * -> * -> *) o a ret. dispatch : leduc_funs (pl2 p1 p2 o a * (f64 -> ret) -> ret) = 
    {
    terminal = fun (pid,reward) (_,ret) => inl r = $"!reward" in ret (if pid = 0 then r else -r)
    action = fun pid ar f ((p1,p2),ret) => 
        // inl next a = ()
        // dispatch (pid,ar,next)
        inl q = p1.observations
        failwith ""
    draw = fun pid ar f => failwith ""
    sample = fun pid ar f => failwith ""
    }