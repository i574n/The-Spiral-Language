inl sample i pid dist f p = cps.sample i pid dist (fun x (p,ret) => ret (f x p)) (p,id)
inl draw i pid dist f p = cps.draw i pid dist (fun x (p,ret) => ret (f x p)) (p,id)

// Iterates over the an uniform categorical distribution, summing up the rewards divided by the length.
inl iter one pid dist f (p,ret) =
    let rec loop i s = 
        inl prob = 1 / f64 (a64.length dist)
        if i < a64.length dist then inl r = one i pid dist f p in loop (i+1) (s+r)
        else ret (prob * s)
    loop 0 0

inl nodes_2p forall (p1 : * -> * -> *) (p2 : * -> * -> *) o a. (run runp1, run runp2) : game2p o a (pl2 p1 p2 o a -> f64) = game2p {
    terminal = fun (pid,r) _ => inl r = f64 r in if pid = 0 then r else -r
    action = fun pid ar f (p1,p2) =>
        if pid = 0 then runp1 p1 (prob p2) ar (fun a,p1 => f a (p1,p2))
        else runp2 p2 (prob p1) ar (fun a,p2 => f a (p1,p2))
    draw = choice draw
    sample = choice sample
    }