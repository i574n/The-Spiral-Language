// Do the GADT constructors work?

nominal tensor dim t = ()
nominal layer_state = ()
nominal row_config = ()

union rec graph t =
    // | Reduce :: forall t. (exists dim a. (layer_state -> a -> t) * graph (tensor dim a)) -> graph t
    | Map :: forall dim t. (exists a. (layer_state -> a -> t) * graph (tensor dim a)) -> graph (tensor dim t)
    | RowMap :: forall t. 
        (exists a. (layer_state -> row_config -> tensor (int * int) a -> int -> tensor (int * int) int -> tensor (int * int) t) * graph (tensor (int * int) a))
        -> graph (tensor (int * int) t)
    | RowReduce :: forall t. 
        (exists a. (layer_state -> row_config -> tensor (int * int) a -> int -> tensor (int * int) int -> t) * graph (tensor (int * int) a))
        -> graph (tensor int t)
    | Zip :: forall dim a b. graph (tensor dim a) * graph (tensor dim b) -> graph (tensor dim (a * b))
    | Matmul :: forall t. graph (tensor (int * int) t) * graph (tensor (int * int) t) -> graph (tensor (int * int) t)
    | Weight :: forall dim t. dim -> graph (tensor dim t)
    | Input :: forall dim t. (exists key{symbol}. key) * dim -> graph (tensor dim t)
    | Apply :: forall b el. (exists a. graph (tensor (a * b) el) * graph a) -> graph (tensor b el)
    | InputScalar :: forall a. (exists key{symbol}. key) -> graph a

nominal graph_dims = ()

// Returns the top level dimension. Takes in a hashmap for memoization purposes.
inl rec get_dim forall dim_top t_top. (h : graph_dims) : graph (tensor dim_top t_top) -> dim_top =
    inl f x = get_dim h x
    function
    | Map(exists a. _, a) => f a
    | RowMap(exists a. _, a) => f a
    | RowReduce(exists a. _, a) => fst (f a)
    | Zip(a,b) =>
        inl a = f a
        inl b = f b
        assert (a = b) "The dimensions of the two inputs to the Zip node have to be equal."
        a
    | Matmul(a,b) =>
        inl (m,k as a) = f a
        inl (n,k') = f b
        assert (k = k') "The inner dimensions of the matrix multiplication node have to be equal."
        m,n
    | Weight dim => dim
    | Input (_, dim) => dim
    | Apply(exists a. a,b) => snd (f a)
    | InputScalar => error_type "Not supposed to have this node in pass_dim."

// inl main() =
//     inl graph : graph (tensor (int * int) float) =
//         Input((exists .input), (1,4))
//     ()
