// #Cuda
let spiral_cuda_codegen (definitions_queue: Queue<TypeOrMethod>) = 
    let buffer_forward_declarations = ResizeArray()
    let buffer_type_definitions = ResizeArray()
    let buffer_method = ResizeArray()
    let buffer_temp = ResizeArray()

    let state x = state_c buffer_temp x
    let enter' x = enter' buffer_temp x
    let enter x = enter state_c buffer_temp x
    let state_new x = state_new buffer_temp x

    let sym_dict = d0()
    let definitions_set = h0()
    definitions_queue |> Seq.iter (definitions_set.Add >> ignore)

    let inline def_enqueue x = def_enqueue definitions_set definitions_queue sym_dict x

    let print_tag_tuple t = def_enqueue print_tag_tuple' t
    let print_tag_union t = def_enqueue print_tag_union' t
    let print_case_union x i = [|print_tag_union x;"Case";string i|] |> String.concat null

    let print_tag_env layout t =
        match layout with
        | None -> def_enqueue print_tag_env' t
        | Some LayoutStack -> def_enqueue print_tag_env_stack' t
        | Some LayoutPackedStack -> def_enqueue print_tag_env_packed_stack' t
        | _ -> failwith "impossible"

    let print_tag_closure' t = sprintf "FunPointer%i" t // Not actual closures. They are only function pointers on the Cuda side.
    let print_tag_closure t = def_enqueue print_tag_closure' t

    let rec print_type restrict_array = function
        | Unit -> "void"
        | MapT _ as x -> print_tag_env None x
        | LayoutT ((LayoutStack | LayoutPackedStack) as layout, _) as x -> print_tag_env (Some layout) x
        | ListT _ as x -> print_tag_tuple x
        | UnionT _ as x -> print_tag_union x
        | ArrayT((ArtCudaLocal | ArtCudaShared | ArtCudaGlobal _),t) -> 
            if restrict_array then sprintf "%s * __restrict__" (print_type false t)
            else sprintf "%s *" (print_type false t)
        | ArrayT _ -> failwith "Not implemented."
        | LayoutT (_, _) | RecT _ | DotNetTypeT _ as x -> failwithf "%s is not supported on the Cuda side." (show_ty x)
        | TermFunctionT _ as t -> print_tag_closure t
        | PrimT x ->
            match x with
            | UInt8T -> "unsigned char"
            | UInt16T -> "unsigned short"
            | UInt32T -> "unsigned int"
            | UInt64T -> "unsigned long long int"
            | Int8T -> "char"
            | Int16T -> "short"
            | Int32T -> "int"
            | Int64T -> "long long int"
            | Float32T -> "float"
            | Float64T -> "double"
            | BoolT -> "char"
            | CharT -> "unsigned short"
            | StringT -> failwith "The string type is not supported on the Cuda side."
        | CudaTypeT x -> codegen_macro (codegen' {branch_return=id; trace=[]}) (print_type false) x
        | LitT _ -> failwith "Should be covered in Unit."
    and print_tyv_with_type restrict_array (tag,ty as v) = sprintf "%s %s" (print_type restrict_array ty) (print_tyv v)
    and codegen' ({branch_return=branch_return; trace=trace} as d) expr =
        let inline codegen expr = codegen' {d with branch_return=id} expr

        //let inline print_method_definition_args x = print_args' print_tyv_with_type x
        let inline print_join_point_args x = 
            let print_with_error_checking x = print_type false (snd x) |> ignore; print_tyv x
            print_args' print_with_error_checking x

        let print_type_array = function // C syntax sucks.
            | ArrayT(ArtCudaLocal,t) -> print_type false t
            | ArrayT(ArtCudaShared,t) -> sprintf "__shared__ %s" (print_type false t)
            | t -> print_type false t
        let print_tyv_with_array (tag,ty as v) = sprintf "%s %s" (print_type_array ty) (print_tyv v)

        let print_value = function
            | LitUInt8 x -> string x 
            | LitUInt16 x -> string x 
            | LitUInt32 x -> string x 
            | LitUInt64 x -> string x 
            | LitInt8 x -> string x
            | LitInt16 x -> string x
            | LitInt32 x -> string x
            | LitInt64 x -> string x
            | LitFloat32 x -> 
                if x = infinityf then "__int_as_float(0x7f800000)"
                elif x = -infinityf then "__int_as_float(0xff800000)"
                elif x = nanf then "__int_as_float(0x7fffffff)"
                else string x
            | LitFloat64 x ->
                if x = infinity then "__longlong_as_double(0x7ff0000000000000ULL)"
                elif x = -infinity then "__longlong_as_double(0xfff0000000000000ULL)"
                elif x = nan then "__longlong_as_double(0xfff8000000000000ULL)"
                else string x
            | LitBool x -> if x then "1" else "0"
            | LitChar x -> string (int x)
            | LitString x -> print_unescaped_string x
                //on_type_er trace "String literals are not supported on the Cuda side."

        let assign_to tyv = function
            | "" as x -> x
            | x -> sprintf "%s = %s" tyv x

        let inline if_ codegen' cond tr fl =
            sprintf "if (%s) {" (codegen cond) |> state_new
            enter <| fun _ -> codegen' tr
            "} else {" |> state_new
            enter <| fun _ -> codegen' fl
            "}" |> state_new

        /// This thing is only here until NVCC gets its act together.
        let inline while_ cond body =
            sprintf "while (%s) {" (codegen cond) |> state_new
            enter <| fun _ -> codegen body
            "}" |> state_new

        let match_with codegen' v cases =
            let print_case =
                match get_type v with
                | UnionT _ as x -> print_case_union x
                | _ -> failwith "Only UnionT can be a type of a match case on the Cuda side."

            let v = codegen v
            let rec loop i = function
                | case :: body :: rest ->
                    sprintf "case %i : {" i |> state_new
                    enter' <| fun _ ->
                        let case_ty = get_type case
                        if is_unit case_ty = false then sprintf "%s %s = %s.data.%s" (print_type false case_ty) (codegen case) v (print_case i) |> state
                        codegen' body |> state
                        "break" |> state
                    "}" |> state_new
                    loop (i+1) rest
                | [] -> ()
                | _ -> failwith "The cases should always be in pairs."

            sprintf "switch (%s.tag) {" v |> state_new
            enter' <| fun _ -> loop 0 cases
            "}" |> state_new

        let make_struct x = make_struct codegen x

        let unsafe_convert tot from =
            let conv_func = 
                match tot with
                | PrimT UInt8T -> "unsigned char"
                | PrimT UInt16T -> "unsigned short"
                | PrimT UInt32T -> "unsigned int"
                | PrimT UInt64T -> "unsigned long long int"
                | PrimT Int8T -> "char"
                | PrimT Int16T -> "short"
                | PrimT Int32T -> "int"
                | PrimT Int64T -> "long long int"
                | PrimT Float32T -> "float"
                | PrimT Float64T -> "double"
                | PrimT CharT -> on_type_er trace "Conversion to char is not supported on the Cuda side."
                | _ -> failwith "impossible"
            sprintf "((%s) (%s))" conv_func (codegen from)

        let inline print_scope tyv f =
            print_tyv_with_type false tyv |> state
            f (codegen' {d with branch_return = assign_to (print_tyv tyv)})

        try
            match expr with
            | TyT Unit | TyV (_, Unit) -> ""
            | TyT t -> //on_type_er trace <| sprintf "Usage of naked type %s as an instance on the term level is invalid." t
                printfn "Error: Naked type on the term level has been generated on the Cuda side. Check the code for the exact location of it."
                sprintf "naked_type /*%s*/" (print_type false t)
            | TyV v -> print_tyv v |> branch_return
            | TyLet(tyv,b,TyV tyv',_,trace) when tyv = tyv' -> codegen' {d with trace=trace} b
            | TyState(b,rest,_,trace) ->
                let d' = {d with branch_return=id; trace=trace}
                match b with
                | TyOp(MutableSet,[ar;idx;b],_) ->
                    match get_type ar with
                    | ArrayT((ArtCudaLocal | ArtCudaShared | ArtCudaGlobal _),_) -> 
                        sprintf "%s[%s] = %s" (codegen' d' ar) (codegen' d' idx) (codegen' d' b) |> state
                    | _ -> failwith "impossible"
                | _ ->
                    let b = codegen' d' b
                    if b <> "" then sprintf "%s" b |> state
                codegen' {d with trace=trace} rest
            | TyLet(tyv,TyOp(IfStatic,[cond;tr;fl],t),rest,_,trace) -> 
                print_scope tyv if_ cond tr fl
                codegen' {d with trace=trace} rest
            | TyLet(tyv,TyOp(Case,v :: cases,t),rest,_,trace) -> 
                print_scope tyv match_with v cases
                codegen' {d with trace=trace} rest
            | TyLet(tyv & (tag,_),b,rest,_,trace) -> 
                let _ = 
                    let d = {d with branch_return=id; trace=trace}
                    match b with
                    | TyOp(ArrayCreate,[a],t) -> sprintf "%s[%s]" (print_tyv_with_array (tag,t)) (codegen' d a)
                    | _ -> sprintf "%s = %s" (print_tyv_with_type false tyv) (codegen' d b) 
                    |> state 
                codegen' {d with trace=trace} rest
            | TyLit x -> print_value x |> branch_return
            | TyJoinPoint(S tag & key,join_point_type,call_args,_) ->
                let method_name = print_method tag
                let tomjp = TomJP (join_point_type,key)
                if definitions_set.Add tomjp then definitions_queue.Enqueue tomjp
                match join_point_type with
                | JoinPointType -> failwith "Should never be printed."
                | JoinPointCuda -> // This join point is just a placeholder.
                    "// Cuda join point" |> state
                    sprintf "// %s(%s)" method_name (print_join_point_args call_args) |> state
                    ""
                | JoinPointMethod -> 
                    sprintf "%s(%s)" method_name (print_join_point_args call_args) |> branch_return
                | JoinPointClosure ->
                    if List.isEmpty call_args then branch_return method_name 
                    else on_type_er trace "The closure should not have free variables on the Cuda side."
            | TyBox(x, t) -> 
                let case_name =
                    let union_idx s = Seq.findIndex ((=) (get_type x)) s
                    match t with
                    | UnionT s -> "make_" + print_case_union t (union_idx s)
                    | _ -> failwith "Only UnionT can be a boxed type."
                if is_unit (get_type x) then sprintf "(%s())" case_name else sprintf "(%s(%s))" case_name (codegen x)
            | TyMap(C env_term, _) ->
                let t = get_type expr
                Map.toArray env_term
                |> Array.map snd
                |> fun x -> make_struct x "" (fun args -> sprintf "(make_%s(%s))" (print_tag_env None t) args)
                |> branch_return
            | TyList l -> let t = get_type expr in make_struct l "" (fun args -> sprintf "make_%s(%s)" (print_tag_tuple t) args) |> branch_return
            | TyOp(op,args,t) ->
                match op, args with
                | Apply,[a;b] ->
                    // Apply during codegen is only used for applying closures.
                    // There is one level of flattening in the outer arguments.
                    // The reason for this is the symmetry between the F# and the Cuda side.
                    let b = tuple_field b |> List.map codegen |> String.concat ", "
                    sprintf "%s(%s)" (codegen a) b
                | Case, v :: cases -> match_with (codegen' d) v cases; ""
                | IfStatic,[cond;tr;fl] -> if_ (codegen' d) cond tr fl; ""
                | While,[cond;body] -> while_ cond body; ""
                | ArrayCreate,[a] -> failwith "ArrayCreate should be done in a let statement on the Cuda side."
                | ArrayIndex,[ar & TyType(ArrayT((ArtCudaLocal | ArtCudaShared | ArtCudaGlobal _),_));idx] -> sprintf "%s[%s]" (codegen ar) (codegen idx)
                | ArrayLength,[a] -> on_type_er trace "The ArrayLlength operation is invalid on the Cuda side as the array is just a pointer."
                | UnsafeConvert,[_;from] -> unsafe_convert t from

                // Primitive operations on expressions.
                | Add,[a;b] -> sprintf "(%s + %s)" (codegen a) (codegen b)
                | Sub,[a;b] -> sprintf "(%s - %s)" (codegen a) (codegen b)
                | Mult,[a;b] -> sprintf "(%s * %s)" (codegen a) (codegen b)
                | Div,[a;b] -> sprintf "(%s / %s)" (codegen a) (codegen b)
                | Mod,[a;b] -> sprintf "(%s %% %s)" (codegen a) (codegen b)
                | Pow,[a;b] -> sprintf "pow(%s, %s)" (codegen a) (codegen b)
                | LT,[a;b] -> sprintf "(%s < %s)" (codegen a) (codegen b)
                | LTE,[a;b] -> sprintf "(%s <= %s)" (codegen a) (codegen b)
                | EQ,[a;b] -> sprintf "(%s == %s)" (codegen a) (codegen b)
                | NEQ,[a;b] -> sprintf "(%s != %s)" (codegen a) (codegen b)
                | GT,[a;b] -> sprintf "(%s > %s)" (codegen a) (codegen b)
                | GTE,[a;b] -> sprintf "(%s >= %s)" (codegen a) (codegen b)
                | BitwiseAnd,[a;b] -> sprintf "(%s & %s)" (codegen a) (codegen b)
                | BitwiseOr,[a;b] -> sprintf "(%s | %s)" (codegen a) (codegen b)
                | BitwiseXor,[a;b] -> sprintf "(%s ^ %s)" (codegen a) (codegen b)

                | ShiftLeft,[x;y] -> sprintf "(%s << %s)" (codegen x) (codegen y)
                | ShiftRight,[x;y] -> sprintf "(%s >> %s)" (codegen x) (codegen y)

                | Neg,[a] -> sprintf "(-%s)" (codegen a)
                | ListIndex,[a;TyLit(LitInt64 b)] -> if_not_unit t <| fun _ -> sprintf "%s.mem_%i" (codegen a) b
                | MapGetField, [r; TyV (i,_)] -> if_not_unit t <| fun _ -> sprintf "%s.mem_%i" (codegen r) i
                | (LayoutToStack | LayoutToPackedStack | LayoutToHeap | LayoutToHeapMutable),[a] ->
                    let {call_args=fv},_ = renamer_apply_typedexpr a
                    match op with
                    | LayoutToStack | LayoutToPackedStack ->
                        let args = List.map print_tyv fv |> List.rev |> String.concat ", "
                        sprintf "make_%s(%s)" (print_tag_env (layout_from_op op |> Some) t) args
                    | LayoutToHeap | LayoutToHeapMutable -> on_type_er trace "Heapify is unsupported on the Cuda side."
                    | _ -> failwith "impossible"
                | Log,[x] -> sprintf "log(%s)" (codegen x)
                | Exp,[x] -> sprintf "exp(%s)" (codegen x)
                | Tanh,[x] -> sprintf "tanh(%s)" (codegen x)
                | Sqrt,[x] -> sprintf "sqrt(%s)" (codegen x)
                | NanIs,[x] -> sprintf "isnan(%s)" (codegen x)
                | FailWith,[x] -> 
                    if settings.cuda_assert_enabled then
                        sprintf "printf(%s)" (codegen x) |> state
                        sprintf "assert(false)" |> state
                    else
                        sprintf "// %s" (codegen x) |> state_new
                    ""
                | MacroCuda,[a] -> codegen_macro codegen (print_type false) a
                | SizeOf,[TyType a] -> sprintf "(sizeof %s)" (print_type false a)

                | x -> failwithf "Compiler error: Missing TyOp case. %A" x
                |> branch_return
        with 
        | :? TypeError -> reraise()
        | e -> on_type_er trace e.Message

    let print_closure_type_definition name (a,r) =
        let ret_ty = print_type false r
        let ty = tuple_field_ty a |> List.map (print_type false) |> String.concat ", "
        sprintf "typedef %s(*%s)(%s)" ret_ty name ty |> state

    let print_union_definition name tys =
        sprintf "struct %s {" name |> state_new
        enter' <| fun _ ->
            "int tag" |> state
            "union {" |> state_new
            enter' <| fun _ ->
                Array.iteri (fun i t -> 
                    if is_unit t = false then
                        sprintf "%s %sCase%i" (print_type false t) name i |> state
                    ) tys
            "} data" |> state
        "}" |> state

        Array.iteri (fun i t ->
            let is_unit_false = is_unit t = false
            let case_name = sprintf "%sCase%i" name i
            if is_unit_false then sprintf "__device__ __forceinline__ %s make_%s(%s v) {" name case_name (print_type false t) |> state_new
            else sprintf "__device__ __forceinline__  %s make_%s() {" name case_name |> state_new
            enter' <| fun _ ->
                sprintf "%s t" name |> state
                sprintf "t.tag = %i" i |> state
                if is_unit_false then sprintf "t.data.%s = v" case_name |> state
                "return t" |> state
            "}" |> state_new
            ) tys

    let print_type_definition layout name tys =
        match layout with
        | Some LayoutPackedStack -> "#pragma pack(1)" |> state
        | _ -> ()

        let args =
            List.map (fun (name,ty) ->
                sprintf "%s %s" (print_type false ty) name
                ) tys

        sprintf "struct %s {" name |> state_new
        enter' <| fun _ -> List.iter state args
        "}" |> state

        sprintf "__device__ __forceinline__ %s make_%s(%s){" name name (String.concat ", " args) |> state_new
        enter' <| fun _ ->
            sprintf "%s tmp" name |> state
            List.iter (fun (x,_) -> sprintf "tmp.%s = %s" x x |> state) tys
            "return tmp" |> state
        "}" |> state_new

    let print_method_definition is_forward_declaration tag (join_point_type, fv, body) =
        let method_name = print_method tag

        let method_return = function
            | "" as x -> x
            | x -> sprintf "return %s" x
        let print_body() = enter <| fun _ -> codegen' {branch_return=method_return; trace=[]} body
        let print_method prefix =
            let args = print_args' (print_tyv_with_type true) fv
            if is_forward_declaration then
                sprintf "%s %s %s(%s)" prefix (print_type false (get_type body)) method_name args |> state
            else
                sprintf "%s %s %s(%s) {" prefix (print_type false (get_type body)) method_name args |> state_new
                print_body()
                "}" |> state_new

        match join_point_type with
        | JoinPointClosure | JoinPointMethod -> print_method "__device__"
        | JoinPointCuda -> print_method "__global__"
        | JoinPointType -> ()

    /// Flattens the types inside out as it encounters them.
    let definitions_set_printed = h0()
    let rec collect_definition x: TypeOrMethod list = 
        let inline f x = collect_definition (TomType x)
        if definitions_set_printed.Add x then
            match x with
            | TomJP (join_point_type,key) ->
                let x' = 
                    match join_point_type with
                    | JoinPointMethod -> 
                        match join_point_dict_method.[key] with
                        | JoinPointDone(a,b) -> a
                        | _ -> failwith "impossible"
                    | JoinPointClosure -> 
                        match join_point_dict_closure.[key] with
                        | JoinPointDone(i,a,b) -> i @ a
                        | _ -> failwith "impossible"
                    | JoinPointCuda -> 
                        match join_point_dict_cuda.[key] with
                        | JoinPointDone(a,b) -> a
                        | _ -> failwith "impossible"
                    | JoinPointType -> failwith "impossible"
                    |> List.collect (f << snd)
                x :: x'
            | TomType ty ->
                match ty with
                | ListT tys -> x :: (List.collect f tys)
                | MapT(tys, _) -> x :: (Map.toList tys |> List.collect (f << snd))
                | LayoutT (_, expr) ->
                    let {call_args=x'},_ = renamer_apply_typedexpr expr
                    x :: (List.collect (f << snd) x')
                | UnionT tys -> x :: (Set.toList tys |> List.collect f)
                | TermFunctionT(a,b) -> x :: f a  @ f b
                | _ -> []
        else
            []

    let print_definition = function
        | TomJP (join_point_type,key) ->
            let fv,body =
                match join_point_type with
                | JoinPointMethod -> 
                    match join_point_dict_method.[key] with
                    | JoinPointDone(a,b) -> a,b
                    | _ -> failwith "impossible"
                | JoinPointClosure -> 
                    match join_point_dict_closure.[key] with
                    | JoinPointDone(_,a,b) -> a,b
                    | _ -> failwith "impossible"
                | JoinPointCuda -> 
                    match join_point_dict_cuda.[key] with
                    | JoinPointDone(a,b) -> a,b
                    | _ -> failwith "impossible"
                | JoinPointType -> failwith "impossible"

            print_method_definition true key.Symbol (join_point_type, fv, body)
            move_to buffer_forward_declarations buffer_temp

            print_method_definition false key.Symbol (join_point_type, fv, body)
            move_to buffer_method buffer_temp
        | TomType ty ->
            match ty with
            | ListT tys -> define_listt ty print_tag_tuple print_type_definition tys
            | MapT(tys, _) -> define_mapt ty print_tag_env print_type_definition tys
            | LayoutT ((LayoutStack | LayoutPackedStack) as layout, expr) ->
                define_layoutt ty print_tag_env print_type_definition layout expr
            | UnionT tys as x -> print_union_definition (print_tag_union x) (Set.toArray tys)
            | TermFunctionT(a,r) as x -> print_closure_type_definition (print_tag_closure x) (a,r)
            | _ -> failwith "impossible"
            move_to buffer_type_definitions buffer_temp


    while definitions_queue.Count > 0 do
        let x = definitions_queue.Dequeue() |> collect_definition
        List.foldBack (fun x _ -> print_definition x) x ()

    "module SpiralExample.Main" |> state_new
    sprintf "let %s = \"\"\"" cuda_kernels_name |> state_new
    settings.cuda_includes |> List.iter (sprintf "#include \"%s\"" >> state_new)
    //if settings.cuda_assert_enabled = false then "#define NDEBUG" |> state_new
    "#include <assert.h>" |> state_new
    state_new ""
    "extern \"C\" {" |> state_new
    enter' <| fun _ ->
        move_to buffer_temp buffer_type_definitions
        move_to buffer_temp buffer_forward_declarations
        state_new ""
        move_to buffer_temp buffer_method
    "}" |> state_new
    "\"\"\"" |> state_new

    buffer_temp |> process_statements